#include <stdio.h>
// ya -> 28, 45, 16, 37, 58; 
// kirill -> 22, 13, 33, 40, 57;


//45(выполненно!!!!)
/*int sort_max(int A[])
{
	int j, k, i;
	int A[] = { 2, 5, 7, 0, 5, 3, 9, 10 };		// Создаём рандомны массив
	int n = 8;
	int max = 0;
	int B[8] = {0};								// Создаём 2-й массив для записи отсортировочных чисел их массива А
	printf("A: ");
	for (i = 0; i < n; i++)
	{
		printf("%d ", A[i]);					// По приколу выводим массив А, чтобы было были видны изменения
	}
	for (j = 0; j < n; j++)
	{
		if (A[j] > max)
		{								// Ищем макс. знач. из массива
			max = A[j];
		}
	}

	for (j = 0; j < n; j++)
	{
		for (k = 0, i = 1; i < n; i++)
		{
			if (A[i] < A[k])
			{								// мин знач
				k = i;						//(4,2,8) (2, 0, 0)|| (4, 9, 8) (2, 4, 0) || (9, 9, 8) (2, 4, 8)
			}
			B[j] = A[k];
		}
		A[k] = max + 1;
	}

	printf("\n\nB: ");
	for (i = 0; i < n; i++)
	{
		printf("%d ", B[i]);
	}
	return 0;
}*/

//16 (выполненно!!!!) * число пользователя, записывается в массив
/*int number_massive(int a)
{
	int i, a;
	//printf("Number: ");			// Задаём нужное число
	//scanf_s("%d", &a);
	int n = a;					// Запомнаем это число в отдельную переменную
	int len = 0;
	do
	{
		len++;				// Считаем скольки символьное у нас число
		a = a / 10;
	} while (a);

	int A[100] = { 0 };			// Создаём массив для записи числа
	for (i = 0; n != 0; i++)
	{
		A[i] = n % 10;				// Записываем цифры в массив(но число записывается наоборот)
		n = n / 10;
	}
	printf("Massive: ");
	for (i = len; i > 0; i--)		// переворачиваю число, чтобы оно выводилось правильно
	{
		printf("%d ", A[i-1]); // Выводим элементы массива A в правильном порядке
	}
	return 0;
}*/

//13(выполненно!!!!) * сумма чисел введеного пользователем числа
/*int sum_numbers(int a)
{
	int k, s;
	s = 0;

	while (a != 0)
	{
		k = a % 10;
		s = s + k;
		a = a / 10;
	}
	return s;
}*/

//37(выполненно!!!!) * макс. повтор. чисел + индекс первого повт.
/*int max_povt_id(int A[])
{
	int A[10] = {4, 2, 1, 1, 9, 1, 7, 5, 1, 9};				// Рандомно заполненный массив
	int n = 10;												// длина массива
	int s = 0;												// Переменные для счета и проверки
	int b = 0;

	for (int i = 0; i < n-1 ; i++)
	{
		int m = 0;
		for (int j = i + 1; j < n; j++)
		{
			if (A[i] == A[j])								// Проверка на повторяющиеся символы
			{
				m++;										// Если символы повторялись, то +1 в счетчик
			}
		}
		if (m > s)
		{
			s = m;							//Записываем локальные переменные в глобальные
			b = i;
		}
	}
	printf("Max povt: %d", s+1);				// Выводим труды нашего кода на экран
	printf("\nIndex max povt: %d", b);

	return 0;
}*/

//58(выполненно!!!!) * считаем отриц. числа / не правильно -> нужно считать полож. отрезки
/*int otric(int A[])
{
	int i, s, k;
	int A[9] = {1, 2, -3, 4, 5, -1, -7, 0, -9};
	for (i=0,s=0,k=0; i<9; i++)
	{
		if (A[i]<0) k=1;
	}
	else
	 {
		if (k==1) s++;
		k=0;
	 }
	 printf("s: %d ", s);

	return 0;
}*/

//22(выполненна!!!!) * прост. числа
/*int prost_num(?) {
	int v = 1000; // значение для поиска простых чисел
	int A[1000]; // массив для хранения простых чисел
	int i, a, n, s;

	for (i = 0, a = 2; a < v; a++) {
		for (s = 0, n = 2; n < a; n++) {
			if (a % n == 0) {
				s = 1;
				break;
			}
		}
		if (s == 0) {
			A[i++] = a;
		}
	}
	A[i] = 0; //  последний элемент массива

	// Вывод простых чисел
	for (int j = 0; A[j] != 0; j++) {
		printf("%d ", A[j]);
	}
	return 0;
}*/

//33(бля!!!!) * скок раз число макс. повторяется в массиве
/*int max_povt(int A[]) {
	system("chcp 1251");											// Подключаем русификатор
	int A[] = { 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5 };			// Создаём массив
	int n = 13;														// размер массива

	int s = 0, b = 0;												// вводим переменные

	for (int i = 0; i < n - 1; i++) {
		if (A[i] == A[i + 1]) {										// Считаем сколько у нас повторяющихся чисел
			int k;
			for (k = 2; i + k < n && A[i] == A[i + k]; k++);		// Это условие было
			if (k > s) {
				s = k;					// строка повторяющихся							// Записываем результаты
				b = i;					// Индекс первого
			}
		}
	}

	printf("Наибольшая последовательность повторяющихся элементов: ");				// Просто вывод массива
	for (int i = b; i < b + s; i++) {
		printf("%d ", A[i]);
	}
	printf("\n");

	return 0;
}*/

//40(выполненно!!!!) * сумма положительных значений
/*int sum_up_znach(int A[]) {
	system("chcp 1251");
	int n = 5;
	int A[] = { 1, 2, 3, 4, -1 };		// Задаём массив(n)

	int s = 0, i;

	for (i = 0; i < n && A[i] > 0; i++) {
		s = s + A[i];							// Сумма положительных значений
	}

	printf("Сумма положительных значений: %d", s);

	return 0;
}*/

//57(выполненно) * предыдушее число в массиве должно быть меньше нынешнего(самый длинный ряд с этим условием)
/*int i1_menihe_i2(int A[]) {
	system("chcp 1251");
	int A[] = { 1, 2, 3, 2, 4, 5, 1, 6, 7 };		// Создаём массив

	int i, s = 0, k = 0;							// Создаём переменые и счётчик

	for (i = 1; i < 10; i++) {
		if (A[i - 1] < A[i]) {						// Проверяем, чтобы предыдущее число было больше нынешнего
			k++;									// Если правда, то +1 к счётчику
		}
		else {
			if (k > s) {							// Записываем максимальную длину последовательности в переменную s
				s = k;
			}
			k = 0;									// Обнуляем счётчик
		}
	}

	printf("Значение s: %d\n", s+1); //s+1					// Вывод результата

	return 0;
}*/

//28(не работает) кратность чисел в массиве
/*int kratnoe(int A[])
{

	int s = 0;
	int A[] = { 1, 4, -6, 8, 9, 1, -4, 6 };
	int n = 8;
	int v = A[0] + 1;

	do
	{
		v--;
		for (int i = 0; i < n ;i++)
		{
			if (A[i] % v != 0)
			{
				s = 1;
				break;
			}
			s = 0;
		}
	} while(s == 1);

	printf("Result: %d", s);

	return 0;
}*/

void sort_max(int A[], int lenght);
void max_povt_id(int A[], int lenght, int* s, int* b);
int sum_numbers(int a);
void mono_ryad(int A[], int length, int* s);
int max_del(int A[], int length);
int sum_poloj_num(int A[], int length);
int sum_poloj_otrez(int A[], int length);


void main()
{
	system("chcp 1251");
	int vibor_user;
	while(1)
	{
		printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n");
		printf("Итак, какую функцию ты хочешь испробывать :)??\n");
		printf("p.s. что бы предварительно закрыть программу введите <0> \n\n");
		printf("<1> - Сортировка по возрастанию(#45)\n<2> - Cумма цифр введеного пользователем числа(#13)	"
			"\n<3> - Число пользователя записывается в массив(#16)\n<4> - Кол-во повторяющихся чисел и первый индекс таких чисел(#37) \
\n<5> - Счёт положительных отрезков(#58)\n<6> - Простые числа(#22)\n<7> - Сумма положительных чисел до первого отрицательного числа(#40) \
\n<8> - Наибольшая последовательность повторяющихся элементов(#33)\n<9> - Максимальное количество возрастающих элементов подряд(#57) \
\n<10> - Наибольший общий делитель элементов массива");

		printf("\nТвой выбор: ");
		scanf_s("%d", &vibor_user);

		if (vibor_user == 1)
		{
			int i, length, A[100];
			printf("\n<Сортировка по возрастанию>");
			printf("\nДлина массива: ");
			scanf_s("%d", &length);
			printf("Объекты массива: ");

			for (i = 0; i < length; i++) {
				scanf_s("%d", &A[i]);
			}
			sort_max(A, length);
			printf("\nВот он, готовенький! :) -> ");

			for (i = 0; i < length; i++) {
				printf("%d ", A[i]);
			}
			printf("\n");
		}

		else if (vibor_user == 2)
		{
			int number;
			printf("\n<Cумма цифр введеного пользователем числа>");
			printf("\nНапиши любое число, которое хочешь -> ");
			scanf_s("%d", &number);
			printf("\nОтветик: %d", sum_numbers(number));
			printf("\n");
		}

		//?
		else if (vibor_user == 3)
		{
			int i, number;
			printf("\n<Число пользователя записывается в массив>");
			printf("\nВведи любое число: ");
			scanf_s("%d", &number);
			int n = number;
			int len = 0;
			do
			{
				len++;							// Считаем скольки символьное у нас число
				number = number / 10;
			} while (number);
			int A[100] = { 0 };
			for (i = 0; n != 0; i++)
			{
				A[i] = n % 10;					// Записываем цифры в массив(но число записывается наоборот)
				n = n / 10;
			}
			printf("\nВот ваше число, но уже в массиве: ");
			for (i = len; i > 0; i--)		// переворачиваю число, чтобы оно выводилось правильно
			{
				printf("'%d' ", A[i - 1]); // Выводим элементы массива A в правильном порядке
			}
			printf("\n");
		}

		else if (vibor_user == 4)
		{
			int i, length, A[100], s, b;
			printf("\n<Кол-во повторяющихся чисел и первый индекс таких чисел>");
			printf("\nДлина массива: ");
			scanf_s("%d", &length);
			printf("Объекты массива: ");

			for (i = 0; i < length; i++)
			{
				scanf_s("%d", &A[i]);
			}
			max_povt_id(A, length, &s, &b);
			printf("\nМаксимально кол-во повторяющихся числел: %d", s + 1);
			printf("\nИндекс макс. повт. числа: %d", b);
			printf("\n");
		}

		else if (vibor_user == 5)									//выводит сколько положительных отрезков в массиве
		{
			int i, length, A[100], s;
			printf("\n<Счёт положительных отрезков между отрицательными числами>");
			printf("\nДлина массива: ");
			scanf_s("%d", &length);
			printf("Объекты массива: ");

			for (i = 0; i < length; i++)
			{
				scanf_s("%d", &A[i]);
			}
			printf("\nМой, Ваш, мой, а нет всё-таки ваш ответик: %d", sum_poloj_otrez(A, length));
			printf("\n");
		}

		//?
		else if (vibor_user == 6)									//выводит сколько положительных отрезков в массиве
		{
			int i, length, A[10000], a, n, s;;
			printf("\n<Простые числа>");
			printf("\nНапишите до какого числа вы бы хотели вывести массив: ");
			scanf_s("%d", &length);

			for (i = 0, a = 2; a <= length; a++)
			{
				for (s = 0, n = 2; n < a; n++) {
					if (a % n == 0) s = 1; break;
				}
				if (s == 0) A[i++] = a;
			}
			A[i] = 0;
			printf("\nВаш ответик: ");
			for (int j = 0; A[j] != 0; j++) {
				printf("%d ", A[j]);
			}
			printf("\n");
		} 

		else if (vibor_user == 7)
		{
			printf("\n<Сумма положительных чисел до первого отрицательного числа>");
			int length, i, s, A[100];
			printf("\nДлина массива: ");
			scanf_s("%d", &length);
			printf("Объекты массива: ");

			for (i = 0; i < length; i++) {
				scanf_s("%d", &A[i]);
			}
			printf("\nСуммммачка, хорошая: %d", sum_poloj_num(A, length));
			printf("\n");
		}

		//?
		else if (vibor_user == 8)
		{
			printf("\n<Наибольшая последовательность повторяющихся элементов>");
			int length, i, s, b, A[100];
			printf("\nДлина массива: ");
			scanf_s("%d", &length);
			printf("Объекты массива: ");

			for (i = 0; i < length; i++) {
				scanf_s("%d", &A[i]);
			}
			s = 0, b = 0;																	// вводим переменные
			for (int i = 0; i < length - 1; i++) {
				if (A[i] == A[i + 1]) {													// Считаем сколько и какие у нас повторяющиеся числа
					int k;
					for (k = 2; i + k < length && A[i] == A[i + k]; k++);
					if (k > s) s = k; b = i;
				}
			}
			printf("\nНаибольшая последовательность повторяющихся элементов: ");					// Просто вывод массива
			for (int i = b; i < b + s; i++) {
				printf("%d ", A[i]);
			}
			printf("\n");
		}	 

		else if (vibor_user == 9)
		{
			int i, s, length, A[100];
			printf("\n<Максимальное количество возрастающих элементов подряд>");
			printf("\nДлина массива: ");
			scanf_s("%d", &length);
			printf("Объекты массива: ");

			for (i = 0; i < length; i++) {
				scanf_s("%d", &A[i]);
			}
			mono_ryad(A, length, &s);
			printf("\nВаш рядик: %d", s + 1); //s+1					
			printf("\n");
		}

		else if (vibor_user == 10)
		{
			printf("\n<Наибольший общий делитель элементов массива>");
			int i, s, length, A[100], v;
			printf("\nДлина массива: ");
			scanf_s("%d", &length);
			printf("Объекты массива: ");

			for (i = 0; i < length; i++) {
				scanf_s("%d", &A[i]);
			}
			int result = max_del(A, length);
			printf("\nВот он, мы все его так долго ждали, наибольший делитель: %d", result);
			printf("\n");
		}

		else if (vibor_user == 0)
		{
			printf("\nСпасибо, что воспользовались программой. Надеюсь вы сможете нам задонатить напокушать :)");
			printf("\n__________________________\n@andscral & @kirill222888|\n");
			return 0;
		}

		else
		{
			printf("\nНЕ ВВОДИ НЕПРАВИЛЬНЫЕ ДАННЫЕ!!\n");
		}
	}

}

void sort_max(int A[], int length)
{
	int j, k, i;
	int max = 0;
	int B[100] = { 0 };
	for (j = 0; j < length; j++)
	{
		if (A[j] > max)
		{								// Ищем макс. знач. из массива
			max = A[j];
		}
	}

	for (j = 0; j < length; j++)
	{
		for (k = 0, i = 1; i < length; i++)
		{
			if (A[i] < A[k])
			{								// мин знач 
				k = i;						//(4,2,8) (2, 0, 0)|| (4, 9, 8) (2, 4, 0) || (9, 9, 8) (2, 4, 8)
			}
			B[j] = A[k];
		}
		A[k] = max + 1;
	}
	for (j = 0; j < length; j++)
	{
		A[j] = B[j];
	}
}
int sum_numbers(int a)
{
	int k, s;
	s = 0;

	while (a != 0)
	{
		k = a % 10;
		s = s + k;
		a = a / 10;
	}
	return s;
}
void max_povt_id(int A[], int length, int* s, int* b)
{
	*s = 0;
	*b = 0;
	for (int i = 0; i < length - 1; i++)
	{
		int m = 0;
		for (int j = i + 1; j < length; j++)
		{
			if (A[i] == A[j])								// Проверка на повторяющиеся символы
			{
				m++;										// Если символы повторялись, то +1 в счетчик
			}
		}
		if (m > *s)
		{
			*s = m;							//Записываем локальные переменные в глобальные
			*b = i;
		}
	}
}
void mono_ryad(int A[], int length, int* s)
{
	*s = 0;
	for (int i = 1, k = 0; i < length; i++) {
		if (A[i] < A[i+1]) {						// Проверяем, чтобы предыдущее число было больше нынешнего
			k++;									// Если правда, то +1 к счётчику
		}
		else {
			if (k > *s) {							// Записываем максимальную длину последовательности в переменную s
				*s = k;
			}
			k = 0;									// Обнуляем счётчик
		}
	}
}
int max_del(int A[], int length)
{
	int v, i, s;
	v = A[0] + 1;
	do {
		v--;
		for (i = 0, s = 0;i < length;i++) {
			if (A[i] % v != 0) { s = 1; break; }
		}
	} while (s == 1);
	return v;
}
int sum_poloj_num(int A[], int length)
{
	int i, s;
	s = 0;
	for (i = 0; i < length && A[i] > 0; i++) {
		s = s + A[i];							// Сумма значений 
	}
	return s;
}
int sum_poloj_otrez(int A[], int length)
{
	int s = 0;
	for (int i = 0, k = 0; i < length; i++)
	{
		if (A[i] < 0) k = 1;
		else
		{
			if (k == 1) s++; k = 0;
		}
	}
	return s;
}
